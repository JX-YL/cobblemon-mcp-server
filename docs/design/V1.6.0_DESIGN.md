# v1.6.0 招式系统完善 - 设计文档

## 📋 目标

**核心目标**：完整支持官方 Cobblemon 招式系统的所有分类

**覆盖率提升**：62% → 75% (+13%)

---

## 🎯 功能需求分析

### 1. 招式分类（基于官方格式）

从参考包分析（`charmander.json`），官方支持 **6 种招式分类**：

| 分类 | 前缀格式 | 示例 | 数量（喷火龙） |
|------|---------|------|---------------|
| **等级招式** | `"等级:招式"` | `"1:scratch"`, `"4:ember"` | 13个 |
| **蛋招式** | `"egg:招式"` | `"egg:bellydrum"` | 10个 |
| **TM招式** | `"tm:招式"` | `"tm:flamethrower"` | 61个 |
| **教学招式** | `"tutor:招式"` | `"tutor:blastburn"` | 22个 |
| **遗留招式** | `"legacy:招式"` | `"legacy:attract"` | 30个 |
| **特殊招式** | `"special:招式"` | `"special:celebrate"` | 5个 |

**官方JSON格式**：所有招式存储在一个数组中
```json
"moves": [
    "1:scratch",
    "1:growl",
    "4:ember",
    "egg:bellydrum",
    "tm:flamethrower",
    "tutor:blastburn",
    "legacy:attract",
    "special:celebrate"
]
```

---

### 2. 当前实现（v1.5.1）的问题

```python
# 当前方式（过于简单）
create_pokemon_with_stats(
    moves=["1:tackle", "5:ember"]  # ❌ 仅支持简单列表
)
```

**问题：**
- ❌ 无法区分招式类型
- ❌ 用户需手动写前缀
- ❌ 无法验证招式是否存在
- ❌ 无法按等级自动排序

---

### 3. v1.6.0 新API设计

#### 方案A：字典分类（推荐）✅

```python
create_pokemon_with_stats(
    name="Charmander",
    
    # 等级招式（字典格式，自动排序）
    level_moves={
        1: ["scratch", "growl"],
        4: ["ember"],
        8: ["smokescreen"],
        12: ["dragonbreath"]
    },
    
    # 蛋招式（列表格式）
    egg_moves=["bellydrum", "dragontail", "metalclaw"],
    
    # TM招式
    tm_moves=["flamethrower", "fireblast", "swordsdance"],
    
    # 教学招式
    tutor_moves=["blastburn", "heatwave", "firepunch"],
    
    # 遗留招式
    legacy_moves=["attract", "return", "toxic"],
    
    # 特殊招式
    special_moves=["celebrate", "howl"]
)
```

**优势：**
- ✅ 清晰的分类
- ✅ 自动格式化（内部转换为 `"1:scratch"` 格式）
- ✅ 自动按等级排序
- ✅ 可单独验证每个招式

#### 方案B：兼容模式（保留旧API）

```python
create_pokemon_with_stats(
    # 旧方式（v1.5.1，仍支持）
    moves=["1:tackle", "egg:bellydrum"],
    
    # 新方式（v1.6.0，推荐）
    level_moves={1: ["scratch"]},
    egg_moves=["bellydrum"]
)
```

**合并逻辑：**
- 如果同时提供 `moves` 和 `level_moves`，则合并
- `moves` 中的内容会被解析并分类

---

## 🔧 技术实现

### 1. 招式验证器（MoveValidator）

**路径**：`tools/validators/move_validator.py`

**功能：**
```python
class MoveValidator:
    """验证招式是否存在"""
    
    # 官方招式列表（从参考数据导入）
    OFFICIAL_MOVES = [
        "tackle", "scratch", "ember", "flamethrower",
        "thunderbolt", "hydropump", ...
    ]
    
    @staticmethod
    def validate_move(move_name: str) -> tuple[bool, str]:
        """验证单个招式"""
        move = move_name.lower().strip()
        if move in MoveValidator.OFFICIAL_MOVES:
            return True, ""
        else:
            suggestions = MoveValidator.get_suggestions(move)
            return False, f"招式 '{move_name}' 不存在。建议：{suggestions}"
    
    @staticmethod
    def get_suggestions(partial: str) -> list:
        """模糊匹配建议"""
        # 使用编辑距离算法
        ...
    
    @staticmethod
    def validate_level_moves(level_moves: dict) -> tuple[bool, list]:
        """验证等级招式"""
        errors = []
        for level, moves in level_moves.items():
            if not isinstance(level, int) or level < 1:
                errors.append(f"等级 {level} 无效（必须 >= 1）")
            for move in moves:
                is_valid, msg = MoveValidator.validate_move(move)
                if not is_valid:
                    errors.append(f"等级 {level}: {msg}")
        return len(errors) == 0, errors
```

---

### 2. 招式格式化器（MoveFormatter）

**路径**：`tools/validators/move_validator.py`（同文件）

**功能：**
```python
class MoveFormatter:
    """格式化招式为官方格式"""
    
    @staticmethod
    def format_level_moves(level_moves: dict) -> list[str]:
        """
        输入：{1: ["scratch", "growl"], 4: ["ember"]}
        输出：["1:scratch", "1:growl", "4:ember"]
        """
        result = []
        for level in sorted(level_moves.keys()):  # 自动排序
            for move in level_moves[level]:
                result.append(f"{level}:{move.lower()}")
        return result
    
    @staticmethod
    def format_egg_moves(egg_moves: list) -> list[str]:
        """
        输入：["bellydrum", "dragontail"]
        输出：["egg:bellydrum", "egg:dragontail"]
        """
        return [f"egg:{move.lower()}" for move in egg_moves]
    
    @staticmethod
    def format_tm_moves(tm_moves: list) -> list[str]:
        """格式化TM招式"""
        return [f"tm:{move.lower()}" for move in tm_moves]
    
    # 同理：tutor_moves, legacy_moves, special_moves
```

---

### 3. server.py 更新

**更新函数签名：**
```python
async def create_pokemon_with_stats(
    # ... 现有参数 ...
    
    # v1.6.0: 招式系统
    level_moves: dict = None,         # {1: ["tackle"], 5: ["ember"]}
    egg_moves: list = None,           # ["bellydrum", "dragontail"]
    tm_moves: list = None,            # ["flamethrower", "fireblast"]
    tutor_moves: list = None,         # ["blastburn", "heatwave"]
    legacy_moves: list = None,        # ["attract", "return"]
    special_moves: list = None,       # ["celebrate"]
    
    # 兼容旧API
    moves: list = None                # ["1:tackle", "egg:bellydrum"]
) -> dict:
```

**处理逻辑：**
```python
from tools.validators.move_validator import MoveValidator, MoveFormatter

# 1. 验证所有招式
all_moves = []

if level_moves:
    is_valid, errors = MoveValidator.validate_level_moves(level_moves)
    if not is_valid:
        raise ValueError(f"等级招式验证失败：{errors}")
    all_moves.extend(MoveFormatter.format_level_moves(level_moves))

if egg_moves:
    for move in egg_moves:
        is_valid, msg = MoveValidator.validate_move(move)
        if not is_valid:
            raise ValueError(f"蛋招式验证失败：{msg}")
    all_moves.extend(MoveFormatter.format_egg_moves(egg_moves))

# 同理处理 tm_moves, tutor_moves, legacy_moves, special_moves

# 2. 合并旧API（兼容模式）
if moves:
    all_moves.extend(moves)

# 3. 添加到species数据
species["moves"] = all_moves
```

---

### 4. 招式参考数据导入

**路径**：`data/official_moves.json`

**格式：**
```json
{
  "moves": [
    "tackle", "scratch", "ember", "flamethrower",
    "thunderbolt", "hydropump", "surf", "earthquake",
    ...
  ],
  "total": 919,
  "source": "Cobblemon 1.5.0 Official",
  "last_updated": "2025-10-28"
}
```

**生成方式：**
- 从官方参考包中提取所有招式名
- 去重、排序
- 保存为JSON

---

## 🧪 测试策略（渐进式）

### Step 1: 基础等级招式
```python
# 测试宝可梦1：Simplemove（简单等级招式）
create_pokemon_with_stats(
    name="Simplemove",
    dex=10001,
    primary_type="normal",
    level_moves={
        1: ["tackle"],
        5: ["quickattack"],
        10: ["bodyslam"]
    }
)
```

### Step 2: 多分类招式
```python
# 测试宝可梦2：Multimove（多分类招式）
create_pokemon_with_stats(
    name="Multimove",
    dex=10002,
    primary_type="fire",
    level_moves={1: ["scratch"], 10: ["ember"]},
    egg_moves=["bellydrum"],
    tm_moves=["flamethrower", "fireblast"]
)
```

### Step 3: 完整招式列表（参考Charmander）
```python
# 测试宝可梦3：Fullmove（完整招式，141个）
create_pokemon_with_stats(
    name="Fullmove",
    dex=10003,
    primary_type="fire",
    level_moves={1: ["scratch", "growl"], 4: ["ember"], ...},
    egg_moves=["bellydrum", "dragontail", ...],
    tm_moves=["flamethrower", "fireblast", ...],
    tutor_moves=["blastburn", "heatwave", ...],
    legacy_moves=["attract", "return", ...],
    special_moves=["celebrate"]
)
```

---

## 📊 验证要点

### 游戏内检查：
1. ✅ `/reload` 无错误
2. ✅ 宝可梦能正常生成
3. ✅ 打开宝可梦菜单，查看招式列表
4. ✅ 招式按等级正确显示
5. ✅ 蛋招式、TM招式正确显示

---

## 📦 交付物

1. ✅ `tools/validators/move_validator.py` - 招式验证器
2. ✅ `data/official_moves.json` - 官方招式参考数据
3. ✅ `server.py` - 更新招式系统支持
4. ✅ `generate_v1.6.0_tests.py` - 测试脚本
5. ✅ `docs/design/V1.6.0_DESIGN.md` - 本设计文档
6. ✅ `README.md` - 更新文档
7. ✅ `CHANGELOG.md` - 更新日志

---

## 🔄 兼容性

- ✅ **向后兼容**：旧的 `moves=["1:tackle"]` 仍可使用
- ✅ **向前兼容**：生成的JSON格式与官方一致
- ✅ **数据迁移**：无需迁移，新旧API可混用

---

## ⚠️ 已知限制

1. **不支持自定义招式**：仅支持官方招式（需要 Cobblemon Mega 等模组）
2. **不支持招式效果**：仅配置招式列表，效果由模组控制
3. **不支持进化招式**：`learnableMoves` 在进化系统中配置

---

## 📈 开发进度

- [x] 需求分析
- [ ] 创建招式验证器
- [ ] 导入官方招式数据
- [ ] 更新 server.py
- [ ] 创建测试脚本
- [ ] 游戏内验证
- [ ] 更新文档

